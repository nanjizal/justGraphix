// Generated by Haxe 5.0.0-alpha.1+1423a5f
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = "Math";
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:true,__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr,__params__:function(){ return [this.v];}}; },$_._hx_name="Left",$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr,__params__:function(){ return [this.v];}}; },$_._hx_name="Right",$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(o.__params__) {
				s = s + "\t";
				var params = o.__params__();
				var _g = 0;
				var _g1 = params.length;
				while(true) {
					if(!(_g < _g1)) {
						break;
					}
					var i = (function($this) {
						var $r;
						_g = _g + 1;
						$r = _g - 1;
						return $r;
					}(this));
					params[i] = js_Boot.__string_rec(params[i],s);
				}
				return (n == null ? "null" : "" + n) + "(" + params.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var justGraphix_contour_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.endCapFactor = 0.5;
	this.useMitre = true;
	this.mitreLimit = 1.2;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.debugCol12 = -893376;
	this.debugCol8 = -12617788;
	this.debugCol7 = -11686193;
	this.debugCol6 = -11288539;
	this.pen = pen_;
	this.endLine = endLine_;
};
justGraphix_contour_Contour.__name__ = "justGraphix.contour.Contour";
justGraphix_contour_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
		case 0:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta0 >= 0) {
				var divisor = Math.ceil(theta0 / (2 * Math.PI)) - 1.;
				out = theta0 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta0;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta1 >= 0) {
				var divisor = Math.ceil(theta1 / (2 * Math.PI)) - 1.;
				out = theta1 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta1;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta0 >= 0) {
				var divisor = Math.ceil(theta0 / (2 * Math.PI)) - 1.;
				out = theta0 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta0;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta1 >= 0) {
				var divisor = Math.ceil(theta1 / (2 * Math.PI)) - 1.;
				out = theta1 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta1;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta0 >= 0) {
				var divisor = Math.ceil(theta0 / (2 * Math.PI)) - 1.;
				out = theta0 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta0;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta1 >= 0) {
				var divisor = Math.ceil(theta1 / (2 * Math.PI)) - 1.;
				out = theta1 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta1;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta0 >= 0) {
				var divisor = Math.ceil(theta0 / (2 * Math.PI)) - 1.;
				out = theta0 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta0;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta1 >= 0) {
				var divisor = Math.ceil(theta1 / (2 * Math.PI)) - 1.;
				out = theta1 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta1;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta0 >= 0) {
				var divisor = Math.ceil(theta0 / (2 * Math.PI)) - 1.;
				out = theta0 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta0;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(theta1 >= 0) {
				var divisor = Math.ceil(theta1 / (2 * Math.PI)) - 1.;
				out = theta1 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -theta1;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = theta0;
			var fb = theta1;
			var theta = Math.abs(theta0 - theta1);
			var smallest = theta <= Math.PI;
			var clockwise = theta0 < theta1;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 >= 0.) {
				var divisor = Math.ceil(theta0 / (2 * Math.PI)) - 1.;
				var temp = theta0 - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				f = temp > Math.PI ? -2 * Math.PI + temp : temp;
			} else {
				var val = -theta0;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				var temp = -(val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				f = temp < -Math.PI ? temp + 2 * Math.PI : temp;
			}
			var start = f;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3 || this.endLine == 6 || this.endLine == 8 || this.endLine == 11 || this.endLine == 9 || this.endLine == 15 || this.endLine == 17 || this.endLine == 12 || this.endLine == 14 || this.endLine == 18 || this.endLine == 20)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			this.startShape(ax,ay,width_ / 2,beta,gamma,justGraphix_rose_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(this.count == 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.ax;
			var ay = this.ay;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var temp = [];
			this.startShape(ax,ay,width_ / 2,beta,gamma,justGraphix_rose_DifferencePreference.SMALL_OLD,temp,-1,36);
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			var color_ = this.debugCol8;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,color_);
			var color_ = this.debugCol12;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,color_);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				var color_ = this.debugCol8;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,color_);
				var color_ = this.debugCol12;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,color_);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var color_ = this.debugCol8;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,color_);
					var color_ = this.debugCol12;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,color_);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					var color_ = this.debugCol8;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,color_);
					var color_ = this.debugCol12;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,color_);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					var color_ = this.debugCol8;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,color_);
					var color_ = this.debugCol12;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,color_);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					var color_ = this.debugCol8;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,color_);
					var color_ = this.debugCol12;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,color_);
				}
			}
		}
		if(this.useMitre) {
			if(this.jx != null && this.jy != null) {
				var deltaX = ax_ - this.jx;
				var deltaY = ay_ - this.jy;
				var mitreCornerX = ax_ + deltaX;
				var mitreCornerY = ay_ + deltaY;
				var distXY = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
				var mitreVal = this.mitreLimit * width_ / 2;
				var mitreLimited = distXY > mitreVal;
				var mitreRatio = mitreVal / distXY;
				if(clockWise) {
					if(!mitreLimited) {
						this.pen.triangle2DFill(this.dxOld,this.dyOld,mitreCornerX,mitreCornerY,this.exPrev,this.eyPrev,-1);
					} else {
						var deltaX1 = this.dxOld + mitreRatio * (mitreCornerX - this.dxOld);
						var deltaY1 = this.dyOld + mitreRatio * (mitreCornerY - this.dyOld);
						var deltaX2 = this.exPrev + mitreRatio * (mitreCornerX - this.exPrev);
						var deltaY2 = this.eyPrev + mitreRatio * (mitreCornerY - this.eyPrev);
						this.pen.triangle2DFill(this.dxOld,this.dyOld,deltaX1,deltaY1,deltaX2,deltaY2,-1);
						this.pen.triangle2DFill(this.dxOld,this.dyOld,deltaX2,deltaY2,this.exPrev,this.eyPrev,-1);
					}
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
				} else {
					if(!mitreLimited) {
						this.pen.triangle2DFill(this.exOld,this.eyOld,mitreCornerX,mitreCornerY,this.dxPrev,this.dyPrev,-1);
					} else {
						var deltaX1 = this.exOld + mitreRatio * (mitreCornerX - this.exOld);
						var deltaY1 = this.eyOld + mitreRatio * (mitreCornerY - this.eyOld);
						var deltaX2 = this.dxPrev + mitreRatio * (mitreCornerX - this.dxPrev);
						var deltaY2 = this.dyPrev + mitreRatio * (mitreCornerY - this.dyPrev);
						this.pen.triangle2DFill(this.exOld,this.eyOld,deltaX1,deltaY1,deltaX2,deltaY2,-1);
						this.pen.triangle2DFill(this.exOld,this.eyOld,deltaX2,deltaY2,this.dxPrev,this.dyPrev,-1);
					}
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
				}
			}
		} else if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx = 0.;
				var cy = 0.;
				var bx = 0.;
				var by = 0.;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
				} else {
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
				}
			} else if(clockWise) {
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0 && (this.endLine == 2 || this.endLine == 3 || this.endLine == 7 || this.endLine == 8 || this.endLine == 11 || this.endLine == 10 || this.endLine == 16 || this.endLine == 17 || this.endLine == 13 || this.endLine == 14 || this.endLine == 19 || this.endLine == 20)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var ddx = ax1 + radius * Math.sin(angle);
			var ddy = ay1 + radius * Math.cos(angle);
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var color_1 = color;
								if(color_1 == null) {
									color_1 = -1;
								}
								this.pen.triangle2DFill(ax1,ay1,gx,gy,ex,ey,color_1);
							}
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this4 = this.endLine;
					if(this4 == 13 || this4 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
		if(this.count != 0 && (this.endLine == 4 || this.endLine == 5)) {
			var ax = this.bx;
			var ay = this.by;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var temp = [];
			var ax1 = ax;
			var ay1 = ay;
			var radius = width_ / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL_OLD._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var beta2 = 0.;
			var this1 = this.endLine;
			if(this1 == 19 || this1 == 20) {
				angle = Math.PI / 2;
				beta2 = 2 * Math.PI - beta + Math.PI / 2;
			}
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var p2 = temp.length;
			var ex = 0.;
			var ey = 0.;
			var fx = 0.;
			var fy = 0.;
			var gx = 0.;
			var gy = 0.;
			var delta = 0.;
			var this1 = this.endLine;
			if(this1 == 13 || this1 == 14) {
				var angle2 = beta - step * totalSteps / 2;
				fx = ax1 - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
				fy = ay1 - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
				radius *= 2;
				delta = Math.pow(radius / 2,2);
			}
			var ddx = ax1 + radius * Math.sin(angle);
			var ddy = ay1 + radius * Math.cos(angle);
			var this1 = this.endLine;
			if(!(this1 == 7 || this1 == 8 || (this1 == 10 || this1 == 11) || (this1 == 16 || this1 == 17))) {
				if(this.endLine == 5) {
					var angle2 = beta - 2 * step * totalSteps;
					ax1 += radius * Math.sin(angle2);
					ay1 += radius * Math.cos(angle2);
					radius *= 2;
				}
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					var this1 = this.endLine;
					if(this1 == 13 || this1 == 14) {
						cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
						cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
						ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
						ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
					} else {
						var this2 = this.endLine;
						if(this2 == 19 || this2 == 20) {
							var ry = this.endCapFactor * radius;
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + ry * Math.cos(angle);
							var cos = Math.cos(beta2);
							var sin = Math.sin(beta2);
							cx -= ax1;
							cy -= ay1;
							var ccx = cx;
							var ccy = cy;
							cx = ccx * cos - ccy * sin;
							cy = ccx * sin + ccy * cos;
							cx += ax1;
							cy += ay1;
						} else {
							cx = ax1 + radius * Math.sin(angle);
							cy = ay1 + radius * Math.cos(angle);
						}
					}
					temp[p2++] = cx;
					temp[p2++] = cy;
					if(i != 0) {
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
						var this3 = this.endLine;
						if(this3 == 13 || this3 == 14) {
							var deltaG = Math.pow(ay1 - gy,2) + Math.pow(ax1 - gx,2);
							var deltaE = Math.pow(ay1 - ey,2) + Math.pow(ax1 - ex,2);
							if(deltaE > delta || deltaG > delta) {
								var color_1 = color;
								if(color_1 == null) {
									color_1 = -1;
								}
								this.pen.triangle2DFill(ax1,ay1,gx,gy,ex,ey,color_1);
							}
						}
					}
					angle += step;
					bx = cx;
					by = cy;
					var this4 = this.endLine;
					if(this4 == 13 || this4 == 14) {
						gx = ex;
						gy = ey;
					}
				}
				if(this.endLine == 4) {
					angle = angle + step * totalSteps / 2 - step;
					cx = ax1 + radius * Math.sin(angle) * Math.sqrt(2);
					cy = ay1 + radius * Math.cos(angle) * Math.sqrt(2);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					bx = cx;
					by = cy;
					angle += step * (totalSteps / 2);
					cx = ax1 + radius * Math.sin(angle);
					cy = ay1 + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					totalSteps += 2;
				}
			} else {
				if(this.endLine == 11 || this.endLine == 10) {
					angle = beta;
					var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					angle = beta - step * totalSteps / 2;
					cx = ax1 - radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 - radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
					bx = cx;
					by = cy;
					angle += step * totalSteps / 2;
					cx = ax1 + radius * this.endCapFactor * Math.sin(angle);
					cy = ay1 + radius * this.endCapFactor * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 7 || this1 == 8) {
						angle = beta;
						var dx = ax1 - radius * Math.sin(angle);
						var dy = ay1 - radius * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ax1 - radius * Math.sin(angle);
						cy = ay1 - radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ddx,ddy,cx,cy,ax1,ay1,color_);
						bx = cx;
						by = cy;
						angle += step * totalSteps / 2;
						cx = ax1 + radius * Math.sin(angle);
						cy = ay1 + radius * Math.cos(angle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax1,ay1,bx,by,cx,cy,color_);
					} else {
						var this1 = this.endLine;
						if(this1 == 16 || this1 == 17) {
							angle = beta;
							var dx = ax1 - radius * this.endCapFactor * Math.sin(angle);
							var dy = ay1 - radius * this.endCapFactor * Math.cos(angle);
							angle = beta - step * totalSteps / 2;
							cx = dx - 2 * radius * this.endCapFactor * Math.sin(angle);
							cy = dy - 2 * radius * this.endCapFactor * Math.cos(angle);
							var lastAngle = angle;
							angle += step * totalSteps / 2;
							ex = ax1 + radius * this.endCapFactor * Math.sin(angle);
							ey = ay1 + radius * this.endCapFactor * Math.cos(angle);
							fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
							fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
							var color_ = color;
							if(color_ == null) {
								color_ = -1;
							}
							this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
						}
					}
				}
				totalSteps += 2;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,color_);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld,color_);
			}
			this.pen.set_pos(this.quadIndex);
			var color_ = this.debugCol6;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,color_);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				var color_ = this.debugCol6;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,color_);
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,color_);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				var color_ = this.debugCol6;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy,color_);
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy,color_);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			var color_ = this.debugCol6;
			if(color_ == null) {
				color_ = -1;
			}
			this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,color_);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,color_);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld,color_);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				var color_ = this.debugCol6;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,color_);
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,color_);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				var color_ = this.debugCol6;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy,color_);
				this.pen.set_pos(this.quadIndex + 1);
				var color_ = this.debugCol7;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy,color_);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 4:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 5:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI / 2;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 6:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 7:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 8:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 9:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 10:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 11:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 12:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 13:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 14:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 15:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 16:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 17:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 18:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 19:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 20:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = ax_ + radius * Math.sin(angle);
			var dy = ay_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(justGraphix_rose_DifferencePreference.SMALL._hx_index) {
			case 0:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 4:
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(beta >= 0) {
					var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
					out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -beta;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var zero = true;
				if(zero == null) {
					zero = false;
				}
				var out;
				if(gamma >= 0) {
					var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
					out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
				} else {
					var val = -gamma;
					var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
					out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
				}
				var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
				var fa = beta;
				var fb = gamma;
				var theta = Math.abs(beta - gamma);
				var smallest = theta <= Math.PI;
				var clockwise = beta < gamma;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx = 0.;
			var cy = 0.;
			var bx = 0.;
			var by = 0.;
			var dx = bx_ + radius * Math.sin(angle);
			var dy = by_ + radius * Math.cos(angle);
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,-1);
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,-1);
	}
	,startShape: function(ax,ay,radius,beta,gamma,prefer,edgePoly,color,sides) {
		if(sides == null) {
			sides = 36;
		}
		if(color == null) {
			color = -1;
		}
		var pi = Math.PI;
		var step = pi * 2 / sides;
		var dif;
		switch(prefer._hx_index) {
		case 0:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(beta >= 0) {
				var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
				out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -beta;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(gamma >= 0) {
				var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
				out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -gamma;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(beta >= 0) {
				var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
				out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -beta;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(gamma >= 0) {
				var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
				out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -gamma;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(beta >= 0) {
				var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
				out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -beta;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(gamma >= 0) {
				var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
				out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -gamma;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(beta >= 0) {
				var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
				out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -beta;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(gamma >= 0) {
				var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
				out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -gamma;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 4:
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(beta >= 0) {
				var divisor = Math.ceil(beta / (2 * Math.PI)) - 1.;
				out = beta - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -beta;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var za = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var zero = true;
			if(zero == null) {
				zero = false;
			}
			var out;
			if(gamma >= 0) {
				var divisor = Math.ceil(gamma / (2 * Math.PI)) - 1.;
				out = gamma - (divisor > 0 ? 2 * Math.PI * divisor : 0);
			} else {
				var val = -gamma;
				var divisor = Math.ceil(val / (2 * Math.PI)) - 1.;
				out = 2 * Math.PI - (val - (divisor > 0 ? 2 * Math.PI * divisor : 0));
			}
			var zb = zero ? out > 2 * Math.PI - 0.000000000000005 && out < 2 * Math.PI + 0.000000000000005 || out > -5e-15 && out < 0.000000000000005 ? 0. : out : out;
			var fa = beta;
			var fb = gamma;
			var theta = Math.abs(beta - gamma);
			var smallest = theta <= Math.PI;
			var clockwise = beta < gamma;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		var positive = dif >= 0;
		var totalSteps = Math.ceil(Math.abs(dif) / step);
		var step = dif / totalSteps;
		var angle = beta;
		var beta2 = 0.;
		var this1 = this.endLine;
		if(this1 == 18 || this1 == 20) {
			angle = Math.PI / 2;
			beta2 = 2 * Math.PI - beta + Math.PI / 2;
		}
		var cx = 0.;
		var cy = 0.;
		var bx = 0.;
		var by = 0.;
		var p2 = edgePoly.length;
		var ex = 0.;
		var ey = 0.;
		var fx = 0.;
		var fy = 0.;
		var gx = 0.;
		var gy = 0.;
		var delta = 0.;
		var this1 = this.endLine;
		if(this1 == 12 || this1 == 14) {
			var angle2 = beta - step * totalSteps / 2;
			fx = ax - 0.75 * this.endCapFactor * radius * Math.sin(angle2);
			fy = ay - 0.75 * this.endCapFactor * radius * Math.cos(angle2);
			radius *= 2;
			delta = Math.pow(radius / 2,2);
		}
		var this1 = this.endLine;
		if(!(this1 == 6 || this1 == 8 || (this1 == 9 || this1 == 11) || (this1 == 15 || this1 == 17))) {
			if(this.endLine == 5) {
				var angle2 = beta - 2 * step * totalSteps;
				ax += radius * Math.sin(angle2);
				ay += radius * Math.cos(angle2);
				radius *= 2;
			}
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				var this1 = this.endLine;
				if(this1 == 12 || this1 == 14) {
					cx = fx + 0.5 * this.endCapFactor * radius * Math.sin(angle);
					cy = fy + 0.5 * this.endCapFactor * radius * Math.cos(angle);
					ex = fx - 0.5 * this.endCapFactor * radius * Math.sin(angle);
					ey = fy - 0.5 * this.endCapFactor * radius * Math.cos(angle);
				} else {
					var this2 = this.endLine;
					if(this2 == 18 || this2 == 20) {
						var ry = this.endCapFactor * radius;
						cx = ax + radius * Math.sin(angle);
						cy = ay + ry * Math.cos(angle);
						var cos = Math.cos(beta2);
						var sin = Math.sin(beta2);
						cx -= ax;
						cy -= ay;
						var ccx = cx;
						var ccy = cy;
						cx = ccx * cos - ccy * sin;
						cy = ccx * sin + ccy * cos;
						cx += ax;
						cy += ay;
					} else {
						cx = ax + radius * Math.sin(angle);
						cy = ay + radius * Math.cos(angle);
					}
				}
				edgePoly[p2++] = cx;
				edgePoly[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
					var this3 = this.endLine;
					if(this3 == 12 || this3 == 14) {
						var deltaG = Math.pow(ay - gy,2) + Math.pow(ax - gx,2);
						var deltaE = Math.pow(ay - ey,2) + Math.pow(ax - ex,2);
						if(deltaE > delta || deltaG > delta) {
							var color_1 = color;
							if(color_1 == null) {
								color_1 = -1;
							}
							this.pen.triangle2DFill(ax,ay,gx,gy,ex,ey,color_1);
						}
					}
				}
				angle += step;
				bx = cx;
				by = cy;
				var this4 = this.endLine;
				if(this4 == 12 || this4 == 14) {
					gx = ex;
					gy = ey;
				}
			}
			if(this.endLine == 4) {
				angle = angle + step * totalSteps / 2 - step;
				cx = ax + radius * Math.sin(angle) * Math.sqrt(2);
				cy = ay + radius * Math.cos(angle) * Math.sqrt(2);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				bx = cx;
				by = cy;
				angle += step * (totalSteps / 2);
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				totalSteps += 2;
			}
		} else {
			var this1 = this.endLine;
			if(this1 == 9 || this1 == 11) {
				angle = beta;
				var ddx = ax - radius * this.endCapFactor * Math.sin(angle);
				var ddy = ay - radius * this.endCapFactor * Math.cos(angle);
				angle = beta - step * totalSteps / 2;
				cx = ax - radius * this.endCapFactor * Math.sin(angle);
				cy = ay - radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
				bx = cx;
				by = cy;
				angle += step * totalSteps / 2;
				cx = ax + radius * this.endCapFactor * Math.sin(angle);
				cy = ay + radius * this.endCapFactor * Math.cos(angle);
				var color_ = color;
				if(color_ == null) {
					color_ = -1;
				}
				this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
			} else {
				var this1 = this.endLine;
				if(this1 == 6 || this1 == 8) {
					angle = beta;
					var ddx = ax - radius * Math.sin(angle);
					var ddy = ay - radius * Math.cos(angle);
					angle = beta + step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ddx,ddy,cx,cy,ax,ay,color_);
					bx = cx;
					by = cy;
					angle -= step * totalSteps / 2;
					cx = ax + radius * Math.sin(angle);
					cy = ay + radius * Math.cos(angle);
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				} else {
					var this1 = this.endLine;
					if(this1 == 15 || this1 == 17) {
						angle = beta;
						var ddx = ax - radius * this.endCapFactor * Math.sin(angle);
						var ddy = ay - radius * this.endCapFactor * Math.cos(angle);
						angle = beta - step * totalSteps / 2;
						cx = ddx - 2 * radius * this.endCapFactor * Math.sin(angle);
						cy = ddy - 2 * radius * this.endCapFactor * Math.cos(angle);
						var lastAngle = angle;
						angle += step * totalSteps / 2;
						ex = ax + radius * this.endCapFactor * Math.sin(angle);
						ey = ay + radius * this.endCapFactor * Math.cos(angle);
						fx = ex - 2 * radius * this.endCapFactor * Math.sin(lastAngle);
						fy = ey - 2 * radius * this.endCapFactor * Math.cos(lastAngle);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,cx,cy,ddx,ddy,color_);
						var color_ = color;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(fx,fy,ddx,ddy,ex,ey,color_);
					}
				}
			}
			totalSteps += 2;
		}
		return totalSteps;
	}
};
var justGraphix_contour_Pen2D = function(col) {
	var this4 = [];
	this4[0] = 0.;
	this.arr = this4;
	this.currentColor = col;
};
justGraphix_contour_Pen2D.__name__ = "justGraphix.contour.Pen2D";
justGraphix_contour_Pen2D.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		justGraphix_contour_io_Array2DTriangles.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			justGraphix_contour_io_Array2DTriangles.set_colorInt(this1,16711680);
		} else {
			justGraphix_contour_io_Array2DTriangles.set_colorInt(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var justGraphix_contour_Sketcher = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.pwmToggle = true;
	this.toggle3 = 0;
	this.distTotal = 0.;
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.wasMove = false;
	this.shortestSeg = 10.;
	this.pwm3 = 3.;
	this.pwm2 = 5.;
	this.pwm1 = 10.;
	this.pen = pen_;
	this.endLine = endLine_;
	this.contour = this.createContour();
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.dash);
		break;
	case 6:
		this.line = $bind(this,this.equidistant);
		break;
	case 7:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.mediumLine);
		break;
	case 9:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 10:
		this.line = $bind(this,this.roundEndLine);
		break;
	case 11:
		this.line = $bind(this,this.mitreLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
justGraphix_contour_Sketcher.__name__ = "justGraphix.contour.Sketcher";
justGraphix_contour_Sketcher.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "src/justGraphix/contour/Sketcher.hx", lineNumber : 42, className : "justGraphix.contour.Sketcher", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "src/justGraphix/contour/Sketcher.hx", lineNumber : 42, className : "justGraphix.contour.Sketcher", methodName : "tracerLine"});
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,crudeLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,roundEndLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width,3);
	}
	,mediumLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,mediumOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false,true);
	}
	,fineLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true);
	}
	,mitreLine: function(x_,y_) {
		this.contour.useMitre = true;
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width);
	}
	,dash: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,equidistant: function(x_,y_) {
	}
	,fineOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true,true);
	}
	,createContour: function() {
		return new justGraphix_contour_Contour(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			if(this.sketchForm == 5) {
				var x1 = x_;
				var y1 = y_;
				var xx = this.x - x_;
				var yy = this.y - y_;
				var a1 = Math.atan2(yy,xx) - Math.PI;
				var sin = Math.sin(a1);
				var cos = Math.cos(a1);
				var dx1 = this.pwm1 * cos;
				var dy1 = this.pwm1 * sin;
				var dx2 = this.pwm2 * cos;
				var dy2 = this.pwm2 * sin;
				var dx3 = this.pwm3 * cos;
				var dy3 = this.pwm3 * sin;
				var dist = sin != 0 ? -yy / sin : cos != 0 ? -xx / cos : 0.;
				if(dist < this.shortestSeg) {
					var x11 = x_;
					var y11 = y_;
					var xx = this.x - x_;
					var yy = this.y - y_;
					var a1 = Math.atan2(yy,xx) - Math.PI;
					var sin = Math.sin(a1);
					var cos = Math.cos(a1);
					var dist1 = sin != 0 ? -yy / sin : cos != 0 ? -xx / cos : 0.;
					this.distTotal += dist1;
					switch(this.toggle3) {
					case 0:
						if(this.pwmToggle) {
							this.line(x_,y_);
							if(this.distTotal > this.pwm1) {
								this.toggle3++;
								this.pwmToggle = !this.pwmToggle;
								this.distTotal = 0.;
							}
						} else {
							this.line(x_,y_);
							if(this.distTotal > this.pwm2) {
								this.toggle3++;
								this.pwmToggle = !this.pwmToggle;
								this.distTotal = 0.;
							}
						}
						break;
					case 1:
						this.wasMove = true;
						var tmp;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp = true;
							break;
						}
						if(tmp) {
							this.contour.end(this.width);
						}
						this.x = x_;
						this.y = y_;
						var l = this.points.length;
						this.points[l] = [];
						this.points[l][0] = x_;
						this.points[l][1] = y_;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = this.dim[this.dim.length - 1];
						if(x_ < d.minX) {
							d.minX = x_;
						}
						if(x_ > d.maxX) {
							d.maxX = x_;
						}
						if(y_ < d.minY) {
							d.minY = y_;
						}
						if(y_ > d.maxY) {
							d.maxY = y_;
						}
						this.contour.reset();
						if(this.distTotal > this.pwm3 + this.width / 2) {
							this.toggle3++;
							this.distTotal = 0.;
						}
						break;
					default:
						this.wasMove = true;
						var tmp;
						switch(this.endLine) {
						case 0:case 1:case 6:case 9:case 12:case 15:case 18:
							tmp = false;
							break;
						case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
							tmp = true;
							break;
						}
						if(tmp) {
							this.contour.end(this.width);
						}
						this.x = x_;
						this.y = y_;
						var l = this.points.length;
						this.points[l] = [];
						this.points[l][0] = x_;
						this.points[l][1] = y_;
						this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
						this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
						this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d = this.dim[this.dim.length - 1];
						if(x_ < d.minX) {
							d.minX = x_;
						}
						if(x_ > d.maxX) {
							d.maxX = x_;
						}
						if(y_ < d.minY) {
							d.minY = y_;
						}
						if(y_ > d.maxY) {
							d.maxY = y_;
						}
						this.contour.reset();
						if(this.distTotal > this.pwm3 + this.width / 2) {
							this.distTotal = 0.;
							if(this.toggle3 == 2) {
								this.toggle3 = 0;
							}
						}
					}
				} else {
					this.distTotal += dist;
					dist -= this.pwm2;
					var px = this.x;
					var py = this.y;
					var pz = 0.;
					px += dx2;
					py += dy2;
					this.wasMove = true;
					var tmp;
					switch(this.endLine) {
					case 0:case 1:case 6:case 9:case 12:case 15:case 18:
						tmp = false;
						break;
					case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
						tmp = true;
						break;
					}
					if(tmp) {
						this.contour.end(this.width);
					}
					this.x = px;
					this.y = py;
					var l = this.points.length;
					this.points[l] = [];
					this.points[l][0] = px;
					this.points[l][1] = py;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = this.dim[this.dim.length - 1];
					if(px < d.minX) {
						d.minX = px;
					}
					if(px > d.maxX) {
						d.maxX = px;
					}
					if(py < d.minY) {
						d.minY = py;
					}
					if(py > d.maxY) {
						d.maxY = py;
					}
					this.contour.reset();
					while(pz < dist) {
						if(this.toggle3 == 0) {
							if(this.pwmToggle) {
								pz += this.pwm1;
								px += dx1;
								py += dy1;
								this.pwmToggle = !this.pwmToggle;
								this.line(px,py);
								if(pz - this.pwm1 > dist) {
									this.distTotal = 0.;
									break;
								}
							} else {
								pz += this.pwm3;
								px += dx3;
								py += dy3;
								this.pwmToggle = !this.pwmToggle;
								this.line(px,py);
								if(pz - this.pwm3 > dist) {
									this.distTotal = 0.;
									break;
								}
							}
						} else {
							if(this.toggle3 == 1) {
								pz += this.pwm1;
								px += dx1;
								py += dy1;
								if(pz - this.pwm1 > dist + this.width / 2) {
									this.distTotal = 0.;
									break;
								}
							} else {
								pz += this.pwm2;
								px += dx2;
								py += dy2;
								if(pz - this.pwm2 > dist + this.width / 2) {
									this.distTotal = 0.;
									break;
								}
							}
							this.wasMove = true;
							var tmp;
							switch(this.endLine) {
							case 0:case 1:case 6:case 9:case 12:case 15:case 18:
								tmp = false;
								break;
							case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
								tmp = true;
								break;
							}
							if(tmp) {
								this.contour.end(this.width);
							}
							this.x = px;
							this.y = py;
							var l = this.points.length;
							this.points[l] = [];
							this.points[l][0] = px;
							this.points[l][1] = py;
							this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
							this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
							this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d = this.dim[this.dim.length - 1];
							if(px < d.minX) {
								d.minX = px;
							}
							if(px > d.maxX) {
								d.maxX = px;
							}
							if(py < d.minY) {
								d.minY = py;
							}
							if(py > d.maxY) {
								d.maxY = py;
							}
							this.contour.reset();
						}
						this.toggle3++;
						if(this.toggle3 == 2) {
							this.toggle3 = 0;
						}
					}
					this.wasMove = true;
					var tmp;
					switch(this.endLine) {
					case 0:case 1:case 6:case 9:case 12:case 15:case 18:
						tmp = false;
						break;
					case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
						tmp = true;
						break;
					}
					if(tmp) {
						this.contour.end(this.width);
					}
					this.x = x_;
					this.y = y_;
					var l = this.points.length;
					this.points[l] = [];
					this.points[l][0] = x_;
					this.points[l][1] = y_;
					this.pointsClock[this.pointsClock.length] = this.contour.pointsClock.slice();
					this.pointsAnti[this.pointsAnti.length] = this.contour.pointsAnti.slice();
					this.dim[this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = this.dim[this.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					this.contour.reset();
					this.x = x1;
					this.y = y1;
				}
			} else {
				this.line(x_,y_);
			}
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
};
var justGraphix_contour_io_Array2DTriangles = {};
justGraphix_contour_io_Array2DTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1];
};
justGraphix_contour_io_Array2DTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1] = v;
	return v;
};
justGraphix_contour_io_Array2DTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1 + 1];
};
justGraphix_contour_io_Array2DTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1 + 1] = v;
	return v;
};
justGraphix_contour_io_Array2DTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 2 + 1];
};
justGraphix_contour_io_Array2DTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 2 + 1] = v;
	return v;
};
justGraphix_contour_io_Array2DTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 7 + 3 + 1];
};
justGraphix_contour_io_Array2DTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 3 + 1] = v;
	return v;
};
justGraphix_contour_io_Array2DTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 4 + 1];
};
justGraphix_contour_io_Array2DTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 4 + 1] = v;
	return v;
};
justGraphix_contour_io_Array2DTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 7 + 5 + 1];
};
justGraphix_contour_io_Array2DTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 5 + 1] = v;
	return v;
};
justGraphix_contour_io_Array2DTriangles.get_color = function(this1) {
	return this1[(this1[0] | 0) * 7 + 6 + 1];
};
justGraphix_contour_io_Array2DTriangles.set_colorInt = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 7 + 6 + 1] = v1;
	return v;
};
justGraphix_contour_io_Array2DTriangles.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	justGraphix_contour_io_Array2DTriangles.set_ax(this1,ax_);
	justGraphix_contour_io_Array2DTriangles.set_ay(this1,ay_);
	justGraphix_contour_io_Array2DTriangles.set_bx(this1,bx_);
	justGraphix_contour_io_Array2DTriangles.set_by(this1,by_);
	justGraphix_contour_io_Array2DTriangles.set_cx(this1,cx_);
	justGraphix_contour_io_Array2DTriangles.set_cy(this1,cy_);
	var windingAdjusted = justGraphix_contour_io_Array2DTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		justGraphix_contour_io_Array2DTriangles.set_ax(this1,ax_);
		justGraphix_contour_io_Array2DTriangles.set_ay(this1,ay_);
		justGraphix_contour_io_Array2DTriangles.set_bx(this1,cx_);
		justGraphix_contour_io_Array2DTriangles.set_by(this1,cy_);
		justGraphix_contour_io_Array2DTriangles.set_cx(this1,bx_);
		justGraphix_contour_io_Array2DTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
justGraphix_contour_io_Array2DTriangles.adjustWinding = function(this1) {
	return justGraphix_contour_io_Array2DTriangles.get_ax(this1) * justGraphix_contour_io_Array2DTriangles.get_by(this1) - justGraphix_contour_io_Array2DTriangles.get_bx(this1) * justGraphix_contour_io_Array2DTriangles.get_ay(this1) + (justGraphix_contour_io_Array2DTriangles.get_bx(this1) * justGraphix_contour_io_Array2DTriangles.get_cy(this1) - justGraphix_contour_io_Array2DTriangles.get_cx(this1) * justGraphix_contour_io_Array2DTriangles.get_by(this1)) + (justGraphix_contour_io_Array2DTriangles.get_cx(this1) * justGraphix_contour_io_Array2DTriangles.get_ay(this1) - justGraphix_contour_io_Array2DTriangles.get_ax(this1) * justGraphix_contour_io_Array2DTriangles.get_cy(this1)) > 0;
};
var justGraphix_contour_io_ColorTriangles2D = {};
justGraphix_contour_io_ColorTriangles2D.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 18 + 2];
};
justGraphix_contour_io_ColorTriangles2D.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 18 + 1 + 2];
};
justGraphix_contour_io_ColorTriangles2D.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 1 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 2 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 18 + 6 + 2];
};
justGraphix_contour_io_ColorTriangles2D.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 6 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.get_by = function(this1) {
	return this1[(this1[0] | 0) * 18 + 7 + 2];
};
justGraphix_contour_io_ColorTriangles2D.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 7 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 8 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 18 + 12 + 2];
};
justGraphix_contour_io_ColorTriangles2D.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 12 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 18 + 13 + 2];
};
justGraphix_contour_io_ColorTriangles2D.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 13 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 14 + 2] = v;
	return v;
};
justGraphix_contour_io_ColorTriangles2D.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	justGraphix_contour_io_ColorTriangles2D.set_ax(this1,ax_);
	justGraphix_contour_io_ColorTriangles2D.set_ay(this1,ay_);
	justGraphix_contour_io_ColorTriangles2D.set_bx(this1,bx_);
	justGraphix_contour_io_ColorTriangles2D.set_by(this1,by_);
	justGraphix_contour_io_ColorTriangles2D.set_cx(this1,cx_);
	justGraphix_contour_io_ColorTriangles2D.set_cy(this1,cy_);
	var windingAdjusted = justGraphix_contour_io_ColorTriangles2D.adjustWinding(this1);
	if(windingAdjusted) {
		justGraphix_contour_io_ColorTriangles2D.set_ax(this1,ax_);
		justGraphix_contour_io_ColorTriangles2D.set_ay(this1,ay_);
		justGraphix_contour_io_ColorTriangles2D.set_bx(this1,cx_);
		justGraphix_contour_io_ColorTriangles2D.set_by(this1,cy_);
		justGraphix_contour_io_ColorTriangles2D.set_cx(this1,bx_);
		justGraphix_contour_io_ColorTriangles2D.set_cy(this1,by_);
	}
	return windingAdjusted;
};
justGraphix_contour_io_ColorTriangles2D.adjustWinding = function(this1) {
	return justGraphix_contour_io_ColorTriangles2D.get_ax(this1) * justGraphix_contour_io_ColorTriangles2D.get_by(this1) - justGraphix_contour_io_ColorTriangles2D.get_bx(this1) * justGraphix_contour_io_ColorTriangles2D.get_ay(this1) + (justGraphix_contour_io_ColorTriangles2D.get_bx(this1) * justGraphix_contour_io_ColorTriangles2D.get_cy(this1) - justGraphix_contour_io_ColorTriangles2D.get_cx(this1) * justGraphix_contour_io_ColorTriangles2D.get_by(this1)) + (justGraphix_contour_io_ColorTriangles2D.get_cx(this1) * justGraphix_contour_io_ColorTriangles2D.get_ay(this1) - justGraphix_contour_io_ColorTriangles2D.get_ax(this1) * justGraphix_contour_io_ColorTriangles2D.get_cy(this1)) > 0;
};
var justGraphix_example_polygon_Banana = function() {
	this.divertTrace = new justGraphix_target__$canvas_DivertTrace();
	haxe_Log.trace("Banana Test",{ fileName : "src/justGraphix/example/polygon/Banana.hx", lineNumber : 47, className : "justGraphix.example.polygon.Banana", methodName : "new"});
	this.width = 1024;
	this.height = 768;
	this.pen2D = new justGraphix_contour_Pen2D(-6428304);
	var s = this.pen2D.arr[0] | 0;
	this.pen2D.currentColor = -858297;
	var sketcher = new justGraphix_contour_Sketcher(this.pen2D,4,0);
	sketcher.width = 20;
	var x_ = justGraphix_example_polygon_Banana_vertices[0][0] / 2;
	var y_ = justGraphix_example_polygon_Banana_vertices[0][1] / 2;
	sketcher.wasMove = true;
	var tmp;
	switch(sketcher.endLine) {
	case 0:case 1:case 6:case 9:case 12:case 15:case 18:
		tmp = false;
		break;
	case 2:case 3:case 4:case 5:case 7:case 8:case 10:case 11:case 13:case 14:case 16:case 17:case 19:case 20:
		tmp = true;
		break;
	}
	if(tmp) {
		sketcher.contour.end(sketcher.width);
	}
	sketcher.x = x_;
	sketcher.y = y_;
	var l = sketcher.points.length;
	sketcher.points[l] = [];
	sketcher.points[l][0] = x_;
	sketcher.points[l][1] = y_;
	sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
	sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
	sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
	var d = sketcher.dim[sketcher.dim.length - 1];
	if(x_ < d.minX) {
		d.minX = x_;
	}
	if(x_ > d.maxX) {
		d.maxX = x_;
	}
	if(y_ < d.minY) {
		d.minY = y_;
	}
	if(y_ > d.maxY) {
		d.maxY = y_;
	}
	sketcher.contour.reset();
	var _g = 0;
	var _g1 = justGraphix_example_polygon_Banana_vertices;
	while(_g < _g1.length) {
		var v = _g1[_g];
		++_g;
		sketcher.lineTo(v[0] / 2,v[1] / 2);
	}
	sketcher.lineTo(justGraphix_example_polygon_Banana_vertices[0][0] / 2,justGraphix_example_polygon_Banana_vertices[0][1] / 2);
	var e = this.pen2D.arr[0] - 1 | 0;
	this.mainSheet = new justGraphix_target__$canvas_Sheet();
	this.mainSheet.create(this.width,this.height,true);
	this.gl = this.mainSheet.gl;
	this.renderer = new justGraphix_target__$gl__$Renderer_Renderer_$(this.gl,this.pen2D,this.width,this.height);
	var this1 = this.renderer;
	var ii_min = s;
	var ii_max = e;
	var range_start = ii_min;
	var range_max = ii_max;
	var data = this1.pen.arr;
	this1.totalTriangles = (data.length - 1) / 6 | 0;
	this1.bufferLength = this1.totalTriangles * 3;
	this1.triSize = 18;
	this1.len = this1.totalTriangles * this1.triSize | 0;
	var this2 = new Float32Array(this1.len + 2);
	this2[0] = 0.;
	this2[1] = 0.;
	this1.arrData = this2;
	var _g = 0;
	var _g1 = this1.totalTriangles;
	while(_g < _g1) {
		var i = _g++;
		this1.pen.arr[0] = i;
		var this2 = this1.arrData;
		this2[0] = i;
		if(this2[0] > this2[1] - 1) {
			this2[1] = this2[0];
		}
		var this3 = this1.arrData;
		var col = justGraphix_contour_io_Array2DTriangles.get_color(data) | 0;
		justGraphix_contour_io_ColorTriangles2D.set_redA(this3,(col >> 16 & 255) / 255);
		var v = (col & 255) / 255;
		this3[(this3[0] | 0) * 18 + 4 + 2] = v;
		var v1 = (col >> 8 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 3 + 2] = v1;
		var v2 = (col >> 24 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 5 + 2] = v2;
		justGraphix_contour_io_ColorTriangles2D.set_redB(this3,(col >> 16 & 255) / 255);
		var v3 = (col & 255) / 255;
		this3[(this3[0] | 0) * 18 + 10 + 2] = v3;
		var v4 = (col >> 8 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 9 + 2] = v4;
		var v5 = (col >> 24 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 11 + 2] = v5;
		justGraphix_contour_io_ColorTriangles2D.set_redC(this3,(col >> 16 & 255) / 255);
		var v6 = (col & 255) / 255;
		this3[(this3[0] | 0) * 18 + 16 + 2] = v6;
		var v7 = (col >> 8 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 15 + 2] = v7;
		var v8 = (col >> 24 & 255) / 255;
		this3[(this3[0] | 0) * 18 + 17 + 2] = v8;
		justGraphix_contour_io_ColorTriangles2D.set_ax(this1.arrData,-(1 - 2 * justGraphix_contour_io_Array2DTriangles.get_ax(data) / this1.width));
		justGraphix_contour_io_ColorTriangles2D.set_ay(this1.arrData,1 - 2 * justGraphix_contour_io_Array2DTriangles.get_ay(data) / this1.height);
		justGraphix_contour_io_ColorTriangles2D.set_bx(this1.arrData,-(1 - 2 * justGraphix_contour_io_Array2DTriangles.get_bx(data) / this1.width));
		justGraphix_contour_io_ColorTriangles2D.set_by(this1.arrData,1 - 2 * justGraphix_contour_io_Array2DTriangles.get_by(data) / this1.height);
		justGraphix_contour_io_ColorTriangles2D.set_cx(this1.arrData,-(1 - 2 * justGraphix_contour_io_Array2DTriangles.get_cx(data) / this1.width));
		justGraphix_contour_io_ColorTriangles2D.set_cy(this1.arrData,1 - 2 * justGraphix_contour_io_Array2DTriangles.get_cy(data) / this1.height);
	}
	var gl = this1.gl;
	var program = gl.createProgram();
	var shader = gl.createShader(35633);
	gl.shaderSource(shader,"attribute vec2 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, .0, 1.0);" + " vcol = vertexColor;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	var shader = gl.createShader(35632);
	gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + "vec4 color = vec4(vcol.rgb, 1. );" + "color *= vcol.a; " + "gl_FragColor = color;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	gl.linkProgram(program);
	var tmp;
	if(!gl.getProgramParameter(program,35714)) {
		throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
	} else {
		gl.validateProgram(program);
		if(!gl.getProgramParameter(program,35715)) {
			throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
		} else {
			gl.useProgram(program);
			tmp = program;
		}
	}
	this1.program = tmp;
	this1.gl.bindBuffer(34962,null);
	this1.gl.useProgram(this1.program);
	var this2 = this1.arrData;
	var arr = this2.subarray(2,(this2[1] | 0) * 18 + 2);
	var gl = this1.gl;
	var program = this1.program;
	var xyName = this1.vertexPosition;
	var rgbaName = this1.vertexColor;
	var isDynamic = true;
	if(isDynamic == null) {
		isDynamic = false;
	}
	var isDynamic1 = isDynamic;
	if(isDynamic1 == null) {
		isDynamic1 = false;
	}
	var buf = gl.createBuffer();
	var staticDraw = 35044;
	var dynamicDraw = 35048;
	var arrayBuffer = 34962;
	gl.bindBuffer(arrayBuffer,buf);
	if(isDynamic1) {
		var arrayBuffer = 34962;
		gl.bufferData(arrayBuffer,arr,dynamicDraw);
	} else {
		var arrayBuffer = 34962;
		gl.bufferData(arrayBuffer,arr,staticDraw);
	}
	var vbo = buf;
	var inp = gl.getAttribLocation(program,xyName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 0 * elementBytes;
	gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	var inp = gl.getAttribLocation(program,rgbaName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 2 * elementBytes;
	gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	this1.buf = vbo;
	this1.gl.bindBuffer(34962,this1.buf);
	this1.gl.useProgram(this1.program);
	var gl = this1.gl;
	var program = this1.program;
	var rgbaName = this1.vertexColor;
	var inp = gl.getAttribLocation(program,this1.vertexPosition);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 0 * elementBytes;
	gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	var inp = gl.getAttribLocation(program,rgbaName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 2 * elementBytes;
	gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	this1.gl.bindBuffer(34962,this1.buf);
	var this2 = this1.arrData;
	this1.currData = this2.subarray(2,(this2[1] | 0) * 18 + 2);
	var this2 = this1.arrData;
	this1.currData = this2.subarray(2,(this2[1] | 0) * 18 + 2);
	var gl = this1.gl;
	var width = this1.width;
	var height = this1.height;
	var r = 0.;
	var g = 0.;
	var b = 0.;
	var a = 1.;
	if(a == null) {
		a = 0.;
	}
	if(b == null) {
		b = 0.;
	}
	if(g == null) {
		g = 0.;
	}
	if(r == null) {
		r = 0.;
	}
	gl.clearColor(r,g,b,a);
	gl.enable(2929);
	gl.clear(16384);
	gl.viewport(0,0,width,height);
	gl.enable(3042);
	gl.blendFunc(1,771);
	gl.enable(2884);
	var partData = this1.currData.subarray(range_start * this1.triSize,range_max * this1.triSize);
	this1.gl.bufferSubData(34962,0,partData);
	this1.gl.useProgram(this1.program);
	this1.gl.drawArrays(4,0,(range_max - range_start) * 3 | 0);
};
justGraphix_example_polygon_Banana.__name__ = "justGraphix.example.polygon.Banana";
function justGraphix_example_polygon_Banana_main() {
	new justGraphix_example_polygon_Banana();
}
var justGraphix_rose_DifferencePreference = $hxEnums["justGraphix.rose.DifferencePreference"] = { __ename__:true,__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"justGraphix.rose.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"justGraphix.rose.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"justGraphix.rose.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"justGraphix.rose.DifferencePreference",toString:$estr}
	,SMALL_OLD: {_hx_name:"SMALL_OLD",_hx_index:4,__enum__:"justGraphix.rose.DifferencePreference",toString:$estr}
};
justGraphix_rose_DifferencePreference.__constructs__ = [justGraphix_rose_DifferencePreference.CLOCKWISE,justGraphix_rose_DifferencePreference.ANTICLOCKWISE,justGraphix_rose_DifferencePreference.SMALL,justGraphix_rose_DifferencePreference.LARGE,justGraphix_rose_DifferencePreference.SMALL_OLD];
var justGraphix_target__$canvas_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
justGraphix_target__$canvas_DivertTrace.__name__ = "justGraphix.target._canvas.DivertTrace";
justGraphix_target__$canvas_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var justGraphix_target__$canvas_Sheet = function() {
};
justGraphix_target__$canvas_Sheet.__name__ = "justGraphix.target._canvas.Sheet";
justGraphix_target__$canvas_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		var body = window.document.body;
		body.style.overflow = "hidden";
		body.style.position = "fixed";
		this.pixelRatio = window.devicePixelRatio;
		if(this.pixelRatio == null) {
			this.pixelRatio = 1.;
		}
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var justGraphix_target__$gl__$Renderer_Renderer_$ = function(gl,pen,width,height) {
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.gl = gl;
	this.pen = pen;
	this.width = width;
	this.height = height;
};
justGraphix_target__$gl__$Renderer_Renderer_$.__name__ = "justGraphix.target._gl._Renderer.Renderer_";
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = "String";
Array.__name__ = "Array";
js_Boot.__toStr = ({ }).toString;
var justGraphix_example_polygon_Banana_vertices = [[132.84375,99.5],[115.71875,183.78125],[45.71875,258.0625],[34.28125,372.375],[60.0,496.65625],[148.5625,612.375],[308.5625,653.78125],[432.84375,613.78125],[505.71875,525.21875],[480.0,489.5],[315.71875,459.5],[251.4375,410.9375],[241.4375,312.375],[215.71875,225.21875],[177.15625,189.5],[222.84375,123.78125]];
justGraphix_example_polygon_Banana_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
